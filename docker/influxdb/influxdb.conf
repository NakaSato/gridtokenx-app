# InfluxDB Configuration for GridTokenX AMI Simulator Engine
# Optimized for high-frequency timestamp data from AMI meter readings

[meta]
  # Where the metadata/raft database is stored
  dir = "/var/lib/influxdb/meta"

[data]
  # The directory where the TSM engine stores TSM files.
  dir = "/var/lib/influxdb/data"

  # The directory where the TSM engine stores WAL files.
  wal-dir = "/var/lib/influxdb/wal"

  # The directory where the TSM engine stores TSI files.
  index-version = "tsi1"

  # The amount of time that a write will wait before fsyncing. A duration
  # greater than 0 can be used to batch up multiple fsync calls. This is useful for slower
  # disks or when experiencing disk write contention. A value of 0s fsyncs every write to the WAL.
  # Optimized for AMI simulator engine's 15-second intervals
  wal-fsync-delay = "1s"

  # The type of shard index to use for new shards. The default is an in-memory index that is
  # recreated at startup. A value of "tsi1" will use a disk based index that supports higher
  # cardinality scenarios at the expense of write throughput.
  # index-version = "inmem"

  # Trace logging for the TSM engine
  trace-logging-enabled = false

  # Whether queries should be logged before execution. Very useful for troubleshooting, but will
  # log any sensitive data contained within a query.
  query-log-enabled = false

  # Settings for the TSM engine optimized for AMI timestamp data

  # CacheMaxMemorySize is the maximum size a shard's cache can
  # reach before it starts rejecting writes.
  # Valid size suffixes are k, m, or g (case insensitive, 1024 = 1k).
  # Setting this value to 0 disables rejection.
  # Increased for AMI simulator engine's high-frequency writes
  cache-max-memory-size = "2g"

  # CacheSnapshotMemorySize is the size at which the engine will
  # snapshot the cache and write it to a TSM file, freeing up memory
  # Valid size suffixes are k, m, or g (case insensitive, 1024 = 1k).
  # Optimized for frequent snapshots with AMI data
  cache-snapshot-memory-size = "50m"

  # CacheSnapshotWriteColdDuration is the length of time at
  # which the engine will snapshot the cache and write it to
  # a new TSM file if the shard hasn't received writes or deletes
  # Shorter duration for AMI simulator engine's continuous data
  cache-snapshot-write-cold-duration = "5m"

  # MinCompactionColdAge is the minimum time that a shard (database and shard group) must
  # be cold before it will be considered for compaction. This setting has no effect on
  # shards with compactions disabled.
  # Optimized for AMI timestamp data patterns
  compact-min-cold-age = "1h"

  # CompactFullWriteColdDuration is the duration at which the engine
  # will compact all TSM files in a shard if it hasn't received a
  # write or delete
  # Faster compaction for AMI simulator data
  compact-full-write-cold-duration = "2h"

  # MaxPointsPerBlock is the maximum number of points in an encoded
  # block in a TSM file. Larger numbers may yield better compression
  # but could incur a performance penalty when querying.
  # Optimized for AMI meter readings (smaller blocks for better query performance)
  max-points-per-block = 500

[coordinator]
  # The default time a write request will wait until a "timeout" error is returned to the caller.
  # Optimized for AMI simulator engine's frequent writes
  write-timeout = "5s"

  # The maximum number of concurrent queries allowed to be executing at one time.
  # Setting this to 0 disables the limit.
  # Increased for AMI simulator analytics queries
  max-concurrent-queries = 10

  # The maximum time a query will is allowed to execute before being killed by the system.
  # Optimized for AMI timestamp range queries
  query-timeout = "30s"

  # The time threshold when a query will be logged as a slow query.
  # This setting has no effect if "query-log-enabled" is false
  # Adjusted for AMI simulator query patterns
  log-queries-after = "5s"

  # The maximum number of connections that may be open at once.
  # Setting this value to 0 disables the limit.
  # Optimized for AMI simulator engine connections
  max-connection-limit = 50

  # Enable the ability to disable the max connection limit
  disable-max-connection-limit = false

[retention]
  # Determines whether retention policy enforcement enabled.
  enabled = true

  # The interval of time when retention policy enforcement checks run.
  # More frequent checks for AMI simulator data
  check-interval = "15m"

[shard-precreation]
  # Determines whether shard pre-creation service is enabled.
  # Essential for AMI simulator engine's predictable timestamp patterns
  enabled = true

  # The interval of time when the check to pre-create new shards runs.
  # More frequent for AMI simulator's regular data patterns
  check-interval = "5m"

  # The advance period in which shards are pre-created.
  # Longer advance period for AMI simulator's continuous data
  advance-period = "2h"

[monitor]
  # Whether to record statistics internally.
  store-enabled = true

  # The destination for recorded statistics
  store-database = "_internal"

  # The interval at which to record statistics
  store-interval = "10s"

[subscriber]
  # Determines whether the subscriber service is enabled.
  enabled = true

  # The default timeout for a subscriber http request to the destination.
  http-timeout = "30s"

  # Whether to disable the subscriber if the destination returns an error.
  # This is useful for scenarios where the destination is expected to return errors.
  # For example, a destination that returns a 429 (Too Many Requests) error.
  disable-on-error = false

  # Whether to not panic and keep retrying on the same error.
  panic-on-error = false

  # The number of writer threads to use when writing to subscribers.
  write-concurrency = 40

  # The number of in-flight writes that should be buffered.
  write-buffer-size = 1000

[http]
  # Determines whether HTTP endpoint is enabled.
  enabled = true

  # The bind address used by the HTTP service.
  bind-address = ":8086"

  # Determines whether HTTP request logging is enabled.
  log-enabled = true

  # Determines whether the HTTP write request logs the body of the request.
  write-tracing = false

  # Determines whether the pprof endpoint is enabled. This endpoint is used for
  # troubleshooting and monitoring.
  pprof-enabled = true

  # Enables authentication on HTTP endpoints.
  auth-enabled = false

  # The default realm sent back when issuing a basic auth challenge.
  realm = "InfluxDB"

  # Determines whether HTTPS is enabled.
  https-enabled = false

  # The SSL certificate to use when HTTPS is enabled.
  https-certificate = "/etc/ssl/influxdb.pem"

  # Use a separate private key location.
  https-private-key = ""

  # The JWT auth shared secret to validate requests using JSON Web Tokens.
  shared-secret = ""

  # The default chunk size for result sets that should be chunked.
  max-row-limit = 0

  # The maximum number of HTTP connections that may be open at once.
  # A value of 0 means no limit.
  max-connection-limit = 0

  # Enable the ability to disable the max connection limit
  disable-max-connection-limit = false

  # Set the limit for the number of idle HTTP connections from clients.
  # A value of 0 means no limit.
  max-idle-connections = 1024

  # Set the maximum duration for which an idle HTTP connection may be kept alive.
  # A value of 0 means no limit.
  max-idle-connection-duration = "1h"

  # Enable http service over unix domain socket.
  unix-socket-enabled = false

  # The path of the unix domain socket.
  bind-socket = "/var/run/influxdb.sock"

  # The maximum size of HTTP request body, in bytes.
  # A value of 0 means no limit.
  max-body-size = 25000000

  # The maximum number of writes handled concurrently.
  # A value of 0 means no limit.
  max-concurrent-write-limit = 0

  # The maximum number of reads handled concurrently.
  # A value of 0 means no limit.
  max-concurrent-read-limit = 0

  # Enable the ability to disable the max concurrent write limit
  disable-max-concurrent-write-limit = false

  # Enable the ability to disable the max concurrent read limit
  disable-max-concurrent-read-limit = false

[logging]
  # Determines which log encoder to use for logs. Available options
  # are auto, logfmt, and json. auto will use a more user friendly
  # output format if the output terminal is a TTY, but the format is not as
  # easily machine-readable. When the output is a non-TTY, auto will use
  # logfmt.
  format = "auto"

  # Determines which level of logs will be emitted. The available levels
  # are error, warn, info, and debug. Logs that are equal to or above the
  # specified level will be emitted.
  level = "info"

  # Suppress the logo output that is printed when the program is started.
  # The logo is always suppressed if STDOUT is not a TTY.
  suppress-logo = false

[[graphite]]
  # Determines whether the graphite endpoint is enabled.
  enabled = false
  database = "graphite"
  retention-policy = ""
  bind-address = ":2003"
  protocol = "tcp"
  consistency-level = "one"

  templates = [
    "*.app env.service.resource.measurement",
    # Default template
    "server.*",
  ]

[[collectd]]
  # Determines whether the collectd endpoint is enabled.
  enabled = false
  bind-address = ":25826"
  database = "collectd"
  retention-policy = ""
  typesdb = "/usr/share/collectd/types.db"

  # These next lines control how batching works. You should have this enabled
  # otherwise you could get dropped metrics or poor performance. Batching
  # will buffer points in memory if you have many coming in.

  # Flush if this many points get buffered
  batch-size = 5000

  # number of batches that may be pending in memory
  batch-pending = 10

  # Flush at least this often even if we haven't hit buffer limit
  batch-timeout = "10s"

[[opentsdb]]
  # Determines whether the OpenTSDB endpoint is enabled.
  enabled = false
  bind-address = ":4242"
  database = "opentsdb"
  retention-policy = ""
  consistency-level = "one"
  # Log incoming OpenTSDB data
  log-point-errors = true

[[udp]]
  # Determines whether the UDP listener is enabled.
  enabled = false
  bind-address = ":8089"
  database = "udp"
  retention-policy = ""

  # These next lines control how batching works. You should have this enabled
  # otherwise you could get dropped metrics or poor performance. Batching
  # will buffer points in memory if you have many coming in.

  # Flush if this many points get buffered
  batch-size = 5000

  # number of batches that may be pending in memory
  batch-pending = 10

  # Flush at least this often even if we haven't hit buffer limit
  batch-timeout = "1s"

[continuous_queries]
  # Determines whether the continuous query service is enabled.
  enabled = true

  # Controls whether queries are logged when executed by the CQ service.
  log-enabled = true

  # Controls whether queries are run on a schedule when the CQ service is enabled.
  run-interval = "1s"