# User Interaction with Anchor Blockchain Programs

This guide demonstrates how users interact with Anchor programs in the GridTokenX P2P Energy Trading System.

## üèóÔ∏è Architecture Overview

### Multi-Program Architecture
- **Registry Program**: User/meter registration and management
- **Energy Token Program**: REC (Renewable Energy Certificate) tokens
- **Trading Program**: P2P energy trading and order matching
- **Oracle Program**: AMI data processing and validation
- **Governance Program**: Proof-of-Authority governance

### Code Generation Pipeline
```
Anchor Programs ‚Üí IDL Files ‚Üí Codama ‚Üí TypeScript Clients ‚Üí React App
```

## üîÑ Complete Interaction Flow

### 1. **User Action in UI**
```tsx
// User clicks a button
<Button onClick={() => registerMutation.mutateAsync({ userType, location })}>
  Register User
</Button>
```

### 2. **React Query Mutation**
```typescript
const registerMutation = useRegistryRegisterUserMutation({ account })
```

### 3. **Wallet Integration**
```typescript
const signer = useWalletUiSigner({ account })
const signAndSend = useWalletUiSignAndSend()
```

### 4. **Generated Instruction Helper**
```typescript
// Auto-generated from Anchor programs
const instruction = getRegisterUserInstruction({
  userAuthority: signer,
  userType: UserType.Prosumer,
  location: "Downtown Campus",
})
```

### 5. **Transaction Execution**
```typescript
const tx = await signAndSend(instruction, signer)
```

### 6. **UI Updates & Feedback**
```typescript
onSuccess: async (tx) => {
  toastTx(tx)  // Show success notification
  await queryClient.invalidateQueries({ 
    queryKey: ['registry', 'accounts', { cluster }] 
  })
}
```

## üìã Real-World Examples

### A. Registry Program - User Registration

#### Rust Program (Simplified)
```rust
#[program]
pub mod registry {
    pub fn register_user(
        ctx: Context<RegisterUser>,
        user_type: UserType,
        location: String,
    ) -> Result<()> {
        let user_account = &mut ctx.accounts.user_account;
        user_account.authority = ctx.accounts.user_authority.key();
        user_account.user_type = user_type;
        user_account.location = location;
        user_account.status = UserStatus::Active;
        // ... rest of implementation
        Ok(())
    }
}
```

#### Generated TypeScript Client
```typescript
// Auto-generated by Codama
export function getRegisterUserInstruction(input: {
  userAuthority: TransactionSigner;
  userType: UserType;
  location: string;
}): TransactionInstruction {
  // Generated instruction builder
}
```

#### React Hook
```typescript
export function useRegistryRegisterUserMutation({ account }: { account: UiWalletAccount }) {
  const signer = useWalletUiSigner({ account })
  const signAndSend = useWalletUiSignAndSend()

  return useMutation({
    mutationFn: async ({ userType, location }) => {
      const instruction = getRegisterUserInstruction({
        userAuthority: signer,
        userType,
        location,
      })
      return await signAndSend(instruction, signer)
    },
    onSuccess: async (tx) => {
      toastTx(tx)
      // Invalidate queries to refresh UI
    }
  })
}
```

#### React Component
```tsx
export function RegistryUiRegisterUser({ account }: { account: UiWalletAccount }) {
  const [userType, setUserType] = useState<'Prosumer' | 'Consumer'>('Consumer')
  const [location, setLocation] = useState('')
  const registerMutation = useRegistryRegisterUserMutation({ account })

  const handleRegister = () => {
    registerMutation.mutateAsync({ userType, location })
  }

  return (
    <div>
      <select value={userType} onChange={(e) => setUserType(e.target.value)}>
        <option value="Consumer">Consumer</option>
        <option value="Prosumer">Prosumer</option>
      </select>
      <input value={location} onChange={(e) => setLocation(e.target.value)} />
      <button onClick={handleRegister}>Register User</button>
    </div>
  )
}
```

### B. Trading Program - Create Energy Order

#### Rust Program
```rust
pub fn create_order(
    ctx: Context<CreateOrder>,
    energy_amount: u64,
    price_per_kwh: u64,
    order_type: OrderType,
    expires_at: i64,
) -> Result<()> {
    let order = &mut ctx.accounts.order;
    order.seller = ctx.accounts.seller.key();
    order.energy_amount = energy_amount;
    order.price_per_kwh = price_per_kwh;
    order.order_type = order_type;
    order.expires_at = expires_at;
    order.status = OrderStatus::Active;
    Ok(())
}
```

#### React Hook for Trading
```typescript
export function useTradingCreateOrderMutation({ account }: { account: UiWalletAccount }) {
  const signer = useWalletUiSigner({ account })
  const signAndSend = useWalletUiSignAndSend()

  return useMutation({
    mutationFn: async ({ 
      energyAmount, 
      pricePerKwh, 
      orderType, 
      expiresAt 
    }: {
      energyAmount: number;
      pricePerKwh: number;
      orderType: 'Sell' | 'Buy';
      expiresAt: number;
    }) => {
      const instruction = getCreateOrderInstruction({
        seller: signer,
        energyAmount: BigInt(energyAmount),
        pricePerKwh: BigInt(pricePerKwh),
        orderType: orderType === 'Sell' ? OrderType.Sell : OrderType.Buy,
        expiresAt: BigInt(expiresAt),
      })
      return await signAndSend(instruction, signer)
    },
    onSuccess: async (tx) => {
      toastTx(tx)
      toast.success('Energy order created successfully!')
    }
  })
}
```

## üîß Development Workflow

### 1. Program Development
```bash
# Edit Anchor programs in anchor/programs/*/src/lib.rs
# Build programs and generate clients
npm run setup
```

### 2. Create Feature Structure
```
src/features/[feature]/
‚îú‚îÄ‚îÄ data-access/
‚îÇ   ‚îú‚îÄ‚îÄ use-[feature]-[action]-mutation.ts
‚îÇ   ‚îî‚îÄ‚îÄ use-[feature]-accounts-query.ts
‚îî‚îÄ‚îÄ ui/
    ‚îî‚îÄ‚îÄ [feature]-ui-[component].tsx
```

### 3. Hook Pattern
```typescript
// Mutation for state-changing operations
export function use[Feature][Action]Mutation({ account }) {
  const signer = useWalletUiSigner({ account })
  const signAndSend = useWalletUiSignAndSend()
  
  return useMutation({
    mutationFn: async (params) => {
      const instruction = get[Action]Instruction({ ...params })
      return await signAndSend(instruction, signer)
    },
    onSuccess: async (tx) => {
      toastTx(tx)
      // Invalidate queries
    }
  })
}

// Query for data fetching
export function use[Feature]AccountsQuery() {
  const { cluster, rpc } = useSolana()
  
  return useQuery({
    queryKey: ['[feature]', 'accounts', { cluster }],
    queryFn: () => get[Feature]ProgramAccounts(rpc),
  })
}
```

## üéØ Key Patterns & Best Practices

### 1. **Transaction Signing Pattern**
```typescript
// Always use wallet signer
const signer = useWalletUiSigner({ account })
const signAndSend = useWalletUiSignAndSend()
await signAndSend(instruction, signer)
```

### 2. **Error Handling**
```typescript
onError: (error) => {
  console.error('Transaction failed:', error)
  toast.error('Operation failed')
}
```

### 3. **Query Invalidation**
```typescript
onSuccess: async (tx) => {
  toastTx(tx)
  await queryClient.invalidateQueries({ 
    queryKey: ['program', 'accounts', { cluster }] 
  })
}
```

### 4. **Loading States**
```tsx
<Button 
  onClick={handleAction}
  disabled={mutation.isPending}
>
  {mutation.isPending ? 'Processing...' : 'Execute Action'}
</Button>
```

### 5. **Account Derivation**
```typescript
// For PDA (Program Derived Address) accounts
const [userAccount] = findProgramAddressSync(
  [Buffer.from('user'), userAuthority.publicKey.toBytes()],
  REGISTRY_PROGRAM_ID
)
```

## üöÄ Advanced Patterns

### Cross-Program Invocations
```rust
// In Rust program - calling another program
let cpi_accounts = TransferToken {
    from: ctx.accounts.from_token_account.to_account_info(),
    to: ctx.accounts.to_token_account.to_account_info(),
    authority: ctx.accounts.authority.to_account_info(),
};
let cpi_program = ctx.accounts.token_program.to_account_info();
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
token::transfer(cpi_ctx, amount)?;
```

### Batch Transactions
```typescript
// Multiple instructions in one transaction
const instructions = [
  getRegisterUserInstruction({ ... }),
  getRegisterMeterInstruction({ ... }),
]
const tx = await signAndSend(instructions, signer)
```

### Real-time Updates with WebSocket
```typescript
// Listen for program account changes
const { cluster, connection } = useSolana()
useEffect(() => {
  const subscription = connection.onAccountChange(
    programAddress,
    (accountInfo) => {
      // Update UI in real-time
      queryClient.invalidateQueries(['program', 'accounts'])
    }
  )
  return () => connection.removeAccountChangeListener(subscription)
}, [connection, programAddress])
```

This comprehensive interaction pattern ensures type-safe, efficient, and user-friendly blockchain interactions in your P2P energy trading system.